#' Generate a list of possible alpha values that are evaluated during training
#' 
#' @return A list of length-three numeric vectors
#' @seealso [list_sampled_alphas()], [alphas_list_to_data_frame()],
#'   [learn_weights()]
#' 
#' @export
#'
#' @examples 
#' list_edge_alphas()
list_edge_alphas <- function() {
  alphas_list_to_data_frame(
    list(
      c(0,0,0), # mean
      c(1,0,0), # random walk
      # c(1,0,1), # random walk
      # c(1,1,0), # NaN
      # c(1,1,1), # NaN
      c(0,1,1), # seasonal naive
      c(0,1,0), # seasonal mean
      c(0,0,1)  # last year's mean
    )
  )
}

#' Generate a list of possible alpha values that are evaluated during training
#' 
#' @param n_target The targeted number of 3-parameter tuples; since the tuples
#'   are generated by a one-time shot sampling (instead of, e.g., rejection
#'   sampling) and only distinct samples are returned, the realized length of
#'   the list of tuples may be shorter than `n_target`. Especially when
#'   `oversample_lower` and/or `oversample_upper` are large compared to the
#'   allowed parameter range, the realized length of the resulting list can
#'   be shorter than `n_target` as many tuples become `{0,1}`-valued.
#' @param alpha_lower A numeric scalar in 0,1 serving as lower bound applied
#'   to the `alpha` parameter of the returned tuples
#' @param alpha_upper A numeric scalar in 0,1 serving as upper bound applied
#'   to the `alpha` parameter of the returned tuples; must be at least as large
#'   as `alpha_lower`. When equal to `alpha_lower`, samples for `alpha` will be
#'   equal to `alpha_lower` will be equal to `alpha_upper` (as that is the
#'   only allowed value).
#' @param alpha_seasonal_lower A numeric scalar in 0,1 serving as lower bound
#'   applied to the `alpha_seasonal` parameter of the returned tuples
#' @param alpha_seasonal_upper A numeric scalar in 0,1 serving as upper bound
#'   applied to the `alpha_seasonal` parameter of the returned tuples; must be
#'   at least as large as `alpha_seasonal_lower`. When equal to
#'   `alpha_seasonal_lower`, samples for `alpha_seasonal` will be equal to
#'   `alpha_seasonal_lower` will be equal to `alpha_seasonal_upper` (as that is
#'   the only allowed value).
#' @param alpha_seasonal_decay_lower A numeric scalar in 0,1 serving as lower
#'   bound applied to the `alpha_seasonal_decay` parameter of returned tuples
#' @param alpha_seasonal_decay_upper A numeric scalar in 0,1 serving as upper
#'   bound applied to the `alpha_seasonal_decay` parameter of the returned
#'   tuples; must be at least as large as `alpha_seasonal_decay_lower`. When
#'   equal to `alpha_seasonal_decay_lower`, samples for `alpha_seasonal_decay`
#'   will be equal to `alpha_seasonal_decay_lower` will be equal to
#'   `alpha_seasonal_decay_upper` (as that is the only allowed value).
#' @param oversample_lower A non-negative numeric scalar adding additional
#'   weight to the parameters' lower bounds during sampling. Since the sampling
#'   generally draws values from a continuous range, the border cases of the
#'   exact lower and upper bound (especially 0 and 1) would never be drawn
#'   even though they represent often well performing special cases. By
#'   specifying `oversample_lower`, explicit probability is assigned to the
#'   lower bound value.
#'   Extends the lower bounds `alpha_lower`, `alpha_seasonal_lower`, 
#'   `alpha_seasonal_decay_lower` to `alpha_lower - oversample_lower` etc.
#'   during sampling of parameters via
#'   `runif(min = alpha_lower - oversample_lower, ...)` etc. After sampling,
#'   parameter values are thresholded back to `alpha_lower` etc.
#'   For the default case of lower bounds equal to 0 and upper bounds equal to
#'   1, the choice of `oversample_lower = 0.05` creates a roughly 5% probability
#'   of returning exactly the lower bound value of 0 as parameter value.
#' @param oversample_upper A non-negative numeric scalar adding additional
#'   weight to the parameters' upper bounds during sampling. Since the sampling
#'   generally draws values from a continuous range, the border cases of the
#'   exact lower and upper bound (especially 0 and 1) would never be drawn
#'   even though they represent often well performing special cases. By
#'   specifying `oversample_upper`, explicit probability is assigned to the
#'   upper bound value.
#'   Extends the upper bounds `alpha_upper`, `alpha_seasonal_upper`, 
#'   `alpha_seasonal_decay_upper` to `alpha_upper + oversample_upper` etc.
#'   during sampling of parameters via
#'   `runif(max = alpha_upper + oversample_upper, ...)` etc. After sampling,
#'   parameter values are thresholded back to `alpha_upper` etc.
#'   For the default case of lower bounds equal to 0 and upper bounds equal to
#'   1, the choice of `oversample_lower = 0.05` creates a roughly 5% probability
#'   of returning exactly the lower bound value of 1 as parameter value.
#' @param include_edge_cases Logical; if `TRUE`, a hardcoded set of tuples
#'   representing special cases of model specifications will be included. Since
#'   these take currently five entries of the list, this is only be useful when
#'   `n_target` is at least of length five. Otherwise the returned list will
#'   contain only (a subset of) the special cases. To achieve that,
#'   [list_edge_alphas()] is the preferred method.
#'   Including the special cases will lead to a comparison of sampled parameters
#'   to benchmarks such as the mean forecast, random walk forecast, or
#'   seasonal naive forecast.
#' @param seed A random seed used while sampling parameters. Will reset the
#'   `.Random.seed` to its value before the function call upon exit.
#' 
#' @return A list of length-three numeric vectors
#' 
#' @seealso [list_edge_alphas()], [alphas_list_to_data_frame()],
#'   [learn_weights()]
#' 
#' @export
#' @examples
#' alphas_grid <- list_sampled_alphas(n_target = 250L)
#' 
#' # ggplot2::ggplot(
#' #   alphas_grid,
#' #   ggplot2::aes(x = alpha, y = alpha_seasonal, fill = alpha_seasonal_decay)
#' # ) +
#' #   ggplot2::geom_point(pch = 21, color = "white") +
#' #   ggplot2::scale_fill_gradient2(midpoint = 0.5) +
#' #   ggplot2::labs(title = "Sampled Grid of Parameters to Evaluate")
#' 
list_sampled_alphas <- function(n_target = 100,
                                alpha_lower = 0,
                                alpha_upper = 1,
                                alpha_seasonal_lower = 0,
                                alpha_seasonal_upper = 1,
                                alpha_seasonal_decay_lower = 0,
                                alpha_seasonal_decay_upper = 1,
                                oversample_lower = 0.05,
                                oversample_upper = 0.05,
                                include_edge_cases = FALSE,
                                seed = NULL) {
  
  checkmate::assert_integerish(
    x = n_target, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = alpha_lower, lower = 0, upper = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = alpha_upper, len = 1, any.missing = FALSE,
    lower = alpha_lower, upper = 1
  )
  checkmate::assert_numeric(
    x = alpha_seasonal_lower, lower = 0, upper = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = alpha_seasonal_upper, lower = alpha_seasonal_lower, upper = 1,
    len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = alpha_seasonal_decay_lower, lower = 0, upper = 1, len = 1,
    any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = alpha_seasonal_decay_upper, lower = alpha_seasonal_decay_lower,
    upper = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = oversample_lower, lower = 0, len = 1, any.missing = FALSE
  )
  checkmate::assert_numeric(
    x = oversample_upper, lower = 0, len = 1, any.missing = FALSE
  )
  checkmate::assert_logical(
    x = include_edge_cases, len = 1, any.missing = FALSE
  )
  checkmate::assert_integerish(
    x = seed, len = 1, null.ok = TRUE, any.missing = FALSE
  )
  
  if (!is.null(seed)) {
    # checking for existence to avoid issues when building vignettes
    if (exists(".Random.seed")) {
      random_seed_current <- .Random.seed
      on.exit({.Random.seed <<- random_seed_current})
    }
    set.seed(seed = seed)
  }
  
  sample_alpha <- function(lower, upper) {
    pmax(
      lower,
      pmin(
        upper,
        stats::runif(
          n = n_target,
          min = lower - oversample_lower,
          max = upper + oversample_upper
        )
      )
    )
  }
  
  grid <- matrix(
    c(
      sample_alpha(
        lower = alpha_lower,
        upper = alpha_upper
      ),
      sample_alpha(
        lower = alpha_seasonal_lower,
        upper = alpha_seasonal_upper
      ),
      sample_alpha(
        lower = alpha_seasonal_decay_lower,
        upper = alpha_seasonal_decay_upper
      )
    ),
    ncol = 3
  )
  
  # Used to avoid special case that generates NaN weights, occuring when both
  # `alpha` and `alpha_seasonal` would be equal to 1
  grid <- grid[!(grid[,1] == 1 & grid[,2] == 1), , drop = FALSE]
  
  if (include_edge_cases) {
    grid <- rbind(
      matrix(
        data = c(
          0, 0, 0,
          1, 0, 0,
          0, 1, 1,
          0, 1, 0,
          0, 0, 1
        ),
        ncol = 3,
        byrow = TRUE
      ),
      grid
    )
  }
  
  grid <- unique(x = grid, MARGIN = 1)
  
  # trim grid down to `n_target` rows in case it has extended due to edge cases
  grid <- grid[seq_len(pmin(n_target, nrow(grid))), , drop = FALSE]
  
  alphas_list_to_data_frame(lapply(
    X = seq_len(nrow(grid)),
    FUN = function(idx) as.numeric(grid[idx, ])
  ))
}

#' Cast a list of alphas as data frame
#' 
#' A helper function that casts a list of parameter tuples (as used for
#' [learn_weights()]) as a named data frame. This is useful to, for example,
#' plot the parameters via `ggplot2`.
#' 
#' @param alphas_grid A list of length 3 parameter tuples as returned by
#'   [list_sampled_alphas()] or [list_edge_alphas()]
#' 
#' @return A data frame with three numeric columns called `alpha`,
#'   `alpha_seasonal`, and `alpha_seasonal_decay`
#'
#' @seealso [list_sampled_alphas()], [list_edge_alphas()]
#' 
#' @keywords internal
#' 
alphas_list_to_data_frame <- function(alphas_grid) {
  checkmate::assert_list(
    x = alphas_grid, types = "numeric", null.ok = FALSE, min.len = 1
  )
  
  alphas_df <- as.data.frame(
    t(
      vapply(
        X = alphas_grid,
        FUN = function(x) return(x),
        FUN.VALUE = numeric(length = 3L)
      )
    )
  )
  
  names(alphas_df) <- c("alpha", "alpha_seasonal", "alpha_seasonal_decay")
  return(alphas_df)
}
