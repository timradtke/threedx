
#' Draw forecast sample paths from a fitted 3DX model
#' 
#' @param object A fitted model object of class `threedx`
#' @param horizon An integer defining the forecast horizon
#' @param n_samples An integer defining the number of sample paths to draw
#' @param observation_driven Logical; if `TRUE`, sample paths are generated by
#'   drawing from weighted historical observations directly instead of adding
#'   innovation noise on the current mean forecast. This is similar to the
#'   Non-Parametric Time Series forecaster (NPTS) described in
#'   "GluonTS: Probabilistic Time Series Models in Python" (2019) by Flunkert et
#'   al. (see https://arxiv.org/abs/1906.05264). If `FALSE`, sample paths will
#'   be generated by adding innovation noise on top of the current weighted
#'   average forecast.
#' @param innovation_function A function with arguments `n` and `errors`. Must
#'   be able to handle additional parameters via `...` to allow for potential
#'   future changes in the set of arguments passed to
#'   `innovation_function` by [predict.threedx()]. For examples, see
#'   [draw_normal_with_drift()] or [draw_bootstrap_weighted()].
#'   The provided `innovation_function` must return a numeric vector of length
#'   `n` that contains i.i.d samples that can be used for any sample path and
#'   forecast horizon.
#'   This argument is ignored when `observation_driven=TRUE`.
#' @param postprocess A function that is applied on a numeric matrix of
#'   drawn samples for a single step-ahead before the samples are used to
#'   update the state of the model, and before outliers are removed
#'   (if applicable). By default equal to `identity()`, but could also
#'   be something like `function(x) pmax(x, 0)` to enforce a lower bound of 0,
#'   or any other transformation of interest that returns a numeric matrix of
#'   same dimensions as those of the input.
#'   Note that this can cause arbitrary errors caused by the author of the
#'   function provided to `postprocess`.
#' @param ... Additional arguments passed to `innovation_function`
#' 
#' @export
#' @examples
#' set.seed(9284)
#' y <- stats::rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi((5 + 1:55 )/ 6)))
#' 
#' model <- learn_weights(
#'   y = y,
#'   alphas_grid = list_sampled_alphas(
#'     n_target = 1000L,
#'     include_edge_cases = TRUE
#'   ),
#'   period_length = 12L,
#'   loss_function = loss_mae
#' )
#' 
#' forecast_observation_driven <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 2500L,
#'   observation_driven = TRUE
#' )
#' 
#' if (require("ggplot2")) {
#'   autoplot(forecast_observation_driven)
#' }
#' 
#' forecast_latent <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 2500L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_bootstrap
#' )
#' 
#' if (require("ggplot2")) {
#'   autoplot(forecast_latent)
#' }
#' 
#' forecast_latent_with_postprocessing <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 2500L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_normal_with_zero_mean,
#'   postprocess = function(x) round(pmax(x, 0))
#' )
#' 
#' if (require("ggplot2")) {
#'   autoplot(forecast_latent_with_postprocessing)
#' }
#' 
predict.threedx <- function(object,
                            horizon,
                            n_samples,
                            observation_driven,
                            innovation_function,
                            postprocess = identity,
                            ...) {
  
  checkmate::assert_class(x = object, classes = "threedx")
  checkmate::assert_logical(
    x = observation_driven, len = 1, any.missing = FALSE
  )
  
  y_m <- matrix(
    data = object$y,
    nrow = n_samples,
    ncol = object$n,
    byrow = TRUE
  )
  
  if (observation_driven) {
    paths <- predict_with_observations(
      y_m = y_m,
      object = object,
      horizon = horizon,
      n_samples = n_samples,
      postprocess = postprocess
    )
  } else {
    paths <- predict_with_state(
      y_m = y_m,
      object = object,
      horizon = horizon,
      n_samples = n_samples,
      innovation_function = innovation_function,
      postprocess = postprocess,
      ...
    )
  }
  
  result <- structure(
    list(
      paths = paths,
      model = object,
      horizon = horizon,
      n_samples = n_samples,
      observation_driven = observation_driven
    ),
    class = "threedx_paths"
  )
  
  return(result)
}

#' Generate sample paths using observed values
#' 
#' @keywords internal
predict_with_observations <- function(y_m,
                                      object,
                                      horizon,
                                      n_samples,
                                      postprocess) {
  
  checkmate::assert_integerish(
    x = horizon, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_integerish(
    x = n_samples, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_function(x = postprocess, null.ok = FALSE, nargs = 1)
  
  y_hat_m <- matrix(
    data = NA_real_,
    nrow = n_samples,
    ncol = horizon
  )
  
  for (idx in seq_len(horizon)) {
    sample_indices <- sample(
      x = seq_len(object$n + idx - 1),
      size = n_samples,
      replace = TRUE,
      prob = weights_threedx(
        alpha = object$alpha,
        alpha_seasonal = object$alpha_seasonal,
        alpha_seasonal_decay = object$alpha_seasonal_decay,
        n = object$n + idx - 1,
        period_length = object$period_length
      )
    )
    
    tmp_y_m <- cbind(y_m, y_hat_m[, seq_len(idx-1), drop = FALSE])
    
    for (sample_idx in seq_len(n_samples)) {
      y_hat_m[sample_idx, idx] <- postprocess(
        tmp_y_m[
          sample_idx, sample_indices[sample_idx]
        ]
      )
    }
  }
  
  return(y_hat_m)
}

#' Generate sample paths using latent state
#' 
#' @keywords internal
predict_with_state <- function(y_m,
                               object,
                               horizon,
                               n_samples,
                               innovation_function,
                               postprocess,
                               ...) {
  
  checkmate::assert_integerish(
    x = horizon, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_integerish(
    x = n_samples, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_function(x = postprocess, null.ok = FALSE, nargs = 1)
  checkmate::assert_function(
    x = innovation_function,
    args = c("n", "errors"),
    ordered = TRUE
  )
  
  if (length(object$residuals) == 0L) {
    stop("The `object$residuals` are of length zero, can't generate innovation
         noise.")
  }
  
  if (all(is.na(object$residuals))) {
    stop("All `residuals` available in `object` are missing, can't generate
         innovation noise.")
  }
  
  y_hat_m <- matrix(
    data = innovation_function(
      n = horizon * n_samples,
      errors = stats::na.omit(object$residuals),
      ...
    ),
    nrow = n_samples,
    ncol = horizon
  )
  
  for (idx in seq_len(horizon)) {
    y_hat_m[, idx] <- postprocess(
      y_hat_m[, idx] +
        cbind(y_m, y_hat_m[, seq_len(idx-1), drop = FALSE]) %*%
        matrix(
          data = weights_threedx(
            alpha = object$alpha,
            alpha_seasonal = object$alpha_seasonal,
            alpha_seasonal_decay = object$alpha_seasonal_decay,
            n = object$n + idx - 1,
            period_length = object$period_length
          ),
          ncol = 1
        )
    )
  }
  
  return(y_hat_m)
}

#' Draw i.i.d. innovations from a Normal distribution with non-zero mean
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' model <- learn_weights(
#'   y = 1:50,
#'   period_length = 12L,
#'   alphas_grid = list_sampled_alphas(n_target = 25),
#'   loss_function = loss_mae
#' )
#' 
#' forecast <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_normal_with_drift,
#' )
draw_normal_with_drift <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  
  suppressWarnings(
    stats::rnorm(
      n = n,
      mean = mean(errors),
      sd = stats::sd(errors)
    )
  )
}

#' Draw i.i.d. innovations from a Normal distribution with zero mean
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' model <- learn_weights(
#'   y = 1:50,
#'   period_length = 12L,
#'   alphas_grid = list_sampled_alphas(n_target = 25),
#'   loss_function = loss_mae
#' )
#' 
#' forecast <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_normal_with_zero_mean,
#' )
draw_normal_with_zero_mean <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  
  suppressWarnings(
    stats::rnorm(
      n = n,
      mean = 0,
      sd = stats::sd(errors)
    )
  )
}

#' Draw innovations by bootstrapping from weighted residual errors
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param weight_function A function that takes `errors` as sole argument and
#'   must return a numeric vector of same length as `errors` to be used as
#'   `prob` argument by the underlying `sample()` call
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' model <- learn_weights(
#'   y = rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi(1:55 / 6))),
#'   period_length = 12L,
#'   alphas_grid = list_sampled_alphas(n_target = 25),
#'   loss_function = loss_mae
#' )
#' 
#' forecast <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_bootstrap_weighted,
#'   weight_function = function(x) {
#'     weights_exponential(alpha = model$alpha, n = length(x))
#'   }
#' )
draw_bootstrap_weighted <- function(n, errors, weight_function, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  checkmate::assert_function(
    x = weight_function,
    nargs = 1L
  )
  
  sample(x = errors, size = n, replace = TRUE, prob = weight_function(errors))
}

#' Draw innovations by bootstrapping from unweighted residual errors
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' model <- learn_weights(
#'   y = rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi(1:55 / 6))),
#'   period_length = 12L,
#'   alphas_grid = list_sampled_alphas(n_target = 25),
#'   loss_function = loss_mae
#' )
#' 
#' forecast <- predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_bootstrap
#' )
#' 
draw_bootstrap <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  sample(x = errors, size = n, replace = TRUE, prob = NULL)
}
