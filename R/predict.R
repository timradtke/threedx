
#' Draw forecast sample paths from a fitted 3DX model
#' 
#' @param object A fitted model object of class `threedx`
#' @param horizon An integer defining the forecast horizon
#' @param n_samples An integer defining the number of sample paths to draw
#' @param observation_driven Logical; if `TRUE`, sample paths are generated by
#'   drawing from weighted historical observations directly instead of adding
#'   innovation noise on the current mean forecast. This is similar to the
#'   Non-Parametric Time Series forecaster (NPTS) described in
#'   "GluonTS: Probabilistic Time Series Models in Python" (2019) by Flunkert et
#'   al. (see https://arxiv.org/abs/1906.05264). If `FALSE`, sample paths will
#'   be generated by adding innovation noise on top of the current weighted
#'   average forecast.
#' @param innovation_function A function with arguments `n` and `errors`. Must
#'   be able to handle additional parameters via `...` to allow for potential
#'   future changes in the set of arguments passed to
#'   `innovation_function` by [predict.threedx()]. For examples, see
#'   [draw_normal_with_drift()] or [draw_bootstrap_weighted()].
#'   The provided `innovation_function` must return a numeric vector of length
#'   `n` that contains i.i.d samples that can be used for any sample path and
#'   forecast horizon.
#'   This argument is ignored when `observation_driven=TRUE`.
#' @param ... Additional arguments passed to `innovation_function`
#' 
#' @export
#' 
predict.threedx <- function(object,
                            horizon,
                            n_samples,
                            observation_driven,
                            innovation_function,
                            ...) {
  
  checkmate::assert_class(x = object, classes = "threedx")
  checkmate::assert_integerish(
    x = horizon, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_integerish(
    x = n_samples, lower = 1, len = 1, any.missing = FALSE
  )
  checkmate::assert_logical(
    x = observation_driven, len = 1, any.missing = FALSE
  )
  
  y_m <- matrix(
    data = object$y,
    nrow = n_samples,
    ncol = object$n,
    byrow = TRUE
  )
  
  if (observation_driven) {
    paths <- predict_with_observations(
      y_m = y_m,
      object = object,
      horizon = horizon,
      n_samples = n_samples
    )
  } else {
    paths <- predict_with_state(
      y_m = y_m,
      object = object,
      horizon = horizon,
      n_samples = n_samples,
      innovation_function = innovation_function,
      ...
    )
  }
  
  result <- structure(
    list(
      paths = paths,
      model = object
    ),
    class = "threedx_paths"
  )
  
  return(result)
}

#' Generate sample paths using observations
#' 
#' @keywords internal
predict_with_observations <- function(y_m,
                                      object,
                                      horizon,
                                      n_samples) {
  y_hat_m <- matrix(
    data = NA_real_,
    nrow = n_samples,
    ncol = horizon
  )
  
  for (idx in seq_len(horizon)) {
    sample_indices <- sample(
      x = seq_len(object$n + idx - 1),
      size = n_samples,
      replace = TRUE,
      prob = weights_threedx(
        alpha = object$alpha,
        alpha_seasonal = object$alpha_seasonal,
        alpha_seasonal_decay = object$alpha_seasonal_decay,
        n = object$n + idx - 1,
        season_length = object$season_length
      )
    )
    
    tmp_y_m <- cbind(y_m, y_hat_m[, seq_len(idx-1), drop = FALSE])
    
    for (sample_idx in seq_len(n_samples)) {
      y_hat_m[sample_idx, idx] <- tmp_y_m[
        sample_idx, sample_indices[sample_idx]
      ]
    }
  }
  
  return(y_hat_m)
}

#' Generate sample paths using latent state
#' 
#' @keywords internal
predict_with_state <- function(y_m,
                               object,
                               horizon,
                               n_samples,
                               innovation_function,
                               ...) {
  
  checkmate::assert_function(
    x = innovation_function,
    args = c("n", "errors"),
    ordered = TRUE
  )
  
  y_hat_m <- matrix(
    data = innovation_function(
      n = horizon * n_samples,
      errors = na.omit(object$residuals),
      ...
    ),
    nrow = n_samples,
    ncol = horizon
  )
  
  for (idx in seq_len(horizon)) {
    y_hat_m[, idx] <- y_hat_m[, idx] +
      cbind(y_m, y_hat_m[, seq_len(idx-1), drop = FALSE]) %*%
      matrix(
        data = weights_threedx(
          alpha = object$alpha,
          alpha_seasonal = object$alpha_seasonal,
          alpha_seasonal_decay = object$alpha_seasonal_decay,
          n = object$n + idx - 1,
          season_length = object$season_length
        ),
        ncol = 1
      )
  }
  
  return(y_hat_m)
}

#' Draw i.i.d. innovations from a Normal distribution with non-zero mean
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_normal_with_drift,
#' )
draw_normal_with_drift <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  
  suppressWarnings(
    stats::rnorm(
      n = n,
      mean = mean(errors),
      sd = stats::sd(errors)
    )
  )
}

#' Draw i.i.d. innovations from a Normal distribution with zero mean
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_normal_with_zero_mean,
#' )
draw_normal_with_zero_mean <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  
  suppressWarnings(
    stats::rnorm(
      n = n,
      mean = 0,
      sd = stats::sd(errors)
    )
  )
}

#' Draw innovations by bootstrapping from weighted residual errors
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param weight_function A function that takes `errors` as sole argument and
#'   must return a numeric vector of same length as `errors` to be used as
#'   `prob` argument by the underlying `sample()` call
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_bootstrap_weighted,
#'   weight_function = function(x) {
#'     weights_exponential(alpha = model$alpha, n = length(x))
#'   }
#' )
draw_bootstrap_weighted <- function(n, errors, weight_function, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  checkmate::assert_function(
    x = weight_function,
    nargs = 1L
  )
  
  sample(x = errors, size = n, replace = TRUE, prob = weight_function(errors))
}

#' Draw innovations by bootstrapping from unweighted residual errors
#' 
#' @param n The number of innovations to draw
#' @param errors The residual errors that are used to define the distribution
#'   from which the innovations are drawn
#' @param ... Additional arguments passed from [predict.threedx()], ignored
#' 
#' @return A vector of same type as `errors` and of length `n`
#' @export
#' 
#' @examples
#' predict(
#'   object = model,
#'   horizon = 12L,
#'   n_samples = 1000L,
#'   observation_driven = FALSE,
#'   innovation_function = draw_bootstrap
#' )
draw_bootstrap <- function(n, errors, ...) {
  checkmate::assert_integerish(x = n, lower = 1, any.missing = FALSE, len = 1)
  checkmate::assert_numeric(x = errors, finite = TRUE, any.missing = FALSE)
  sample(x = errors, size = n, replace = TRUE, prob = NULL)
}
