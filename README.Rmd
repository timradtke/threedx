---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "svglite",
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

```{r, echo = FALSE}
# set a seed to always draw the same paths;
# only to not having to re-commit slightly changed SVGs
set.seed(9284)
```

# threedx (3DX)

<!-- badges: start -->
<!-- badges: end -->

Use 3DX to generate interpretable probabilistic forecasts purely by weighting values from the observed time series.

What's unique about 3DX is that it can be used to derive forecasts not only based on a "latent state" but also observation-driven, drawing future realizations purely from observed values. This can be effective for count or intermittent series.

## Installation

You can install the development version of threedx from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("timradtke/threedx")
```

Written in pure R, and with the `checkmate` package as the only direct dependency, installing `threedx` is a breeze.

## Get Started

```{r example_series}
y <- rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi(1:55 / 6)))
plot(y)
```

```{r forecast_with_threedx}
library(threedx)

alphas_grid <- list_sampled_alphas(n_target = 1000L)

model <- learn_weights(
  y = y,
  alphas_grid = alphas_grid,
  season_length = 12L,
  loss_function = loss_mae
)

forecast <- predict(
  object = model,
  horizon = 12L,
  n_samples = 2500L,
  observation_driven = TRUE
)
```

```{r plot_forecast, echo = FALSE}
n_obs <- length(y)
horizon <- 12

plot(c(1, n_obs + horizon), c(0, 20), type = "n",
     xlab = "Index", ylab = "Value")
points(y, pch = 19, cex = (model$weights - min(model$weights)) / (max(model$weights) - min(model$weights)))
points(y, pch = 1)
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, quantile, 0.05), col = "grey")
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, quantile, 0.95), col = "grey")
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, quantile, 0.2), col = "darkgrey")
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, quantile, 0.8), col = "darkgrey")
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, median))
lines((n_obs+1):(n_obs+horizon), apply(forecast$paths, 2, mean), lty = 2)
```
