% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/list_alphas.R
\name{list_sampled_alphas}
\alias{list_sampled_alphas}
\title{Generate a list of possible alpha values that are evaluated during training}
\usage{
list_sampled_alphas(
  n_target = 100,
  alpha_lower = 0,
  alpha_upper = 1,
  alpha_seasonal_lower = 0,
  alpha_seasonal_upper = 1,
  alpha_seasonal_decay_lower = 0,
  alpha_seasonal_decay_upper = 1,
  oversample_lower = 0.05,
  oversample_upper = 0.05,
  include_edge_cases = FALSE,
  seed = NULL
)
}
\arguments{
\item{n_target}{The targeted number of 3-parameter tuples; since the tuples
are generated by a one-time shot sampling (instead of, e.g., rejection
sampling) and only distinct samples are returned, the realized length of
the list of tuples may be shorter than \code{n_target}. Especially when
\code{oversample_lower} and/or \code{oversample_upper} are large compared to the
allowed parameter range, the realized length of the resulting list can
be shorter than \code{n_target} as many tuples become \verb{\{0,1\}}-valued.}

\item{alpha_lower}{A numeric scalar in 0,1 serving as lower bound applied
to the \code{alpha} parameter of the returned tuples}

\item{alpha_upper}{A numeric scalar in 0,1 serving as upper bound applied
to the \code{alpha} parameter of the returned tuples; must be at least as large
as \code{alpha_lower}. When equal to \code{alpha_lower}, samples for \code{alpha} will be
equal to \code{alpha_lower} will be equal to \code{alpha_upper} (as that is the
only allowed value).}

\item{alpha_seasonal_lower}{A numeric scalar in 0,1 serving as lower bound
applied to the \code{alpha_seasonal} parameter of the returned tuples}

\item{alpha_seasonal_upper}{A numeric scalar in 0,1 serving as upper bound
applied to the \code{alpha_seasonal} parameter of the returned tuples; must be
at least as large as \code{alpha_seasonal_lower}. When equal to
\code{alpha_seasonal_lower}, samples for \code{alpha_seasonal} will be equal to
\code{alpha_seasonal_lower} will be equal to \code{alpha_seasonal_upper} (as that is
the only allowed value).}

\item{alpha_seasonal_decay_lower}{A numeric scalar in 0,1 serving as lower
bound applied to the \code{alpha_seasonal_decay} parameter of returned tuples}

\item{alpha_seasonal_decay_upper}{A numeric scalar in 0,1 serving as upper
bound applied to the \code{alpha_seasonal_decay} parameter of the returned
tuples; must be at least as large as \code{alpha_seasonal_decay_lower}. When
equal to \code{alpha_seasonal_decay_lower}, samples for \code{alpha_seasonal_decay}
will be equal to \code{alpha_seasonal_decay_lower} will be equal to
\code{alpha_seasonal_decay_upper} (as that is the only allowed value).}

\item{oversample_lower}{A non-negative numeric scalar adding additional
weight to the parameters' lower bounds during sampling. Since the sampling
generally draws values from a continuous range, the border cases of the
exact lower and upper bound (especially 0 and 1) would never be drawn
even though they represent often well performing special cases. By
specifying \code{oversample_lower}, explicit probability is assigned to the
lower bound value.
Extends the lower bounds \code{alpha_lower}, \code{alpha_seasonal_lower},
\code{alpha_seasonal_decay_lower} to \code{alpha_lower - oversample_lower} etc.
during sampling of parameters via
\code{runif(min = alpha_lower - oversample_lower, ...)} etc. After sampling,
parameter values are thresholded back to \code{alpha_lower} etc.
For the default case of lower bounds equal to 0 and upper bounds equal to
1, the choice of \code{oversample_lower = 0.05} creates a roughly 5\% probability
of returning exactly the lower bound value of 0 as parameter value.}

\item{oversample_upper}{A non-negative numeric scalar adding additional
weight to the parameters' upper bounds during sampling. Since the sampling
generally draws values from a continuous range, the border cases of the
exact lower and upper bound (especially 0 and 1) would never be drawn
even though they represent often well performing special cases. By
specifying \code{oversample_upper}, explicit probability is assigned to the
upper bound value.
Extends the upper bounds \code{alpha_upper}, \code{alpha_seasonal_upper},
\code{alpha_seasonal_decay_upper} to \code{alpha_upper + oversample_upper} etc.
during sampling of parameters via
\code{runif(max = alpha_upper + oversample_upper, ...)} etc. After sampling,
parameter values are thresholded back to \code{alpha_upper} etc.
For the default case of lower bounds equal to 0 and upper bounds equal to
1, the choice of \code{oversample_lower = 0.05} creates a roughly 5\% probability
of returning exactly the lower bound value of 1 as parameter value.}

\item{include_edge_cases}{Logical; if \code{TRUE}, a hardcoded set of tuples
representing special cases of model specifications will be included. Since
these take currently five entries of the list, this is only be useful when
\code{n_target} is at least of length five. Otherwise the returned list will
contain only (a subset of) the special cases. To achieve that,
\code{\link[=list_edge_alphas]{list_edge_alphas()}} is the preferred method.
Including the special cases will lead to a comparison of sampled parameters
to benchmarks such as the mean forecast, random walk forecast, or
seasonal naive forecast.}

\item{seed}{A random seed used while sampling parameters. Will reset the
\code{.Random.seed} to its value before the function call upon exit.}
}
\value{
A list of length-three numeric vectors
}
\description{
Generate a list of possible alpha values that are evaluated during training
}
\examples{
alphas_grid <- list_sampled_alphas(n_target = 250L)

# ggplot2::ggplot(
#   alphas_list_to_data_frame(alphas_grid),
#   ggplot2::aes(x = alpha, y = alpha_seasonal, fill = alpha_seasonal_decay)
# ) +
#   ggplot2::geom_point(pch = 21, color = "white") +
#   ggplot2::scale_fill_gradient2(midpoint = 0.5) +
#   ggplot2::labs(title = "Sampled Grid of Parameters to Evaluate")

}
\seealso{
\code{\link[=list_edge_alphas]{list_edge_alphas()}}, \code{\link[=alphas_list_to_data_frame]{alphas_list_to_data_frame()}},
\code{\link[=learn_weights]{learn_weights()}}
}
