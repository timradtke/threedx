% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/learn_weights.R
\name{learn_weights}
\alias{learn_weights}
\title{Fit a 3DX model to a time series}
\usage{
learn_weights(
  y,
  period_length,
  alphas_grid,
  loss_function,
  penalize = FALSE,
  loss_increase = 1
)
}
\arguments{
\item{y}{The time series to be forecasted as numeric vector (not as \code{ts()}
object)}

\item{period_length}{The presumed length of \code{y}'s seasonal period; for
example, \code{12L} for monthly observations, \code{7L} for daily observations, ...}

\item{alphas_grid}{A data frame of possible parameter combinations to
generate the weights of the final model. The optimal parameter set will be
chosen based on the minimization of \code{loss_function}. The expected columns
are numeric and called \code{alpha}, \code{alpha_seasonal}, \code{alpha_seasonal_decay}.
At least one row must be provided. All values must be between 0 and 1.
Use, for example, \code{\link[=list_sampled_alphas]{list_sampled_alphas()}} or
\code{\link[=list_edge_alphas]{list_edge_alphas()}} to generate this data frame, or generate it in any way
you like.}

\item{loss_function}{A function with first argument \code{y_hat} and optionally
more arguments. Usually, to compute a loss, at least an additional \code{y}
argument is required to compute errors. Must be able to handle additional
parameters via \code{...} to allow for potential future changes in the set of
arguments passed to \code{loss_function} by \code{\link[=learn_weights]{learn_weights()}}.
For examples, see \code{\link[=loss_mae]{loss_mae()}} or \code{\link[=loss_mae_with_observation_weight]{loss_mae_with_observation_weight()}}.
It can be assumed that the arguments \code{y_hat} and \code{y} passed by
\code{\link[=learn_weights]{learn_weights()}} are numeric vectors of equal length.
The provided \code{loss_function} must return a numeric scalar value.}

\item{penalize}{Logical, \code{FALSE} by default. If \code{TRUE}, will try to pick
a set of parameters that are simpler while not increasing the loss too
much. The allowed increase in loss in percentage points is defined via the
\code{loss_increase}. A model is simpler if more of its parameters are
equal to exactly zero or one, as these correspond to the edge cases.}

\item{loss_increase}{A non-negative scalar value by which the loss may be
increased compared to the best possible loss, in percentage points. This
argument is ignored unless \code{penalize = TRUE}. The default of \code{1}
corresponds to a range of up to a 1 percentage point increase in loss.}
}
\value{
A fitted model object of class \code{threedx}, which is a list of:
\itemize{
\item A numeric vector \code{weights} of the same length as the input \code{y}, assigning
a weight to each index of the past observations. The weights sum to 1.
These weights are the fitted weights used to produce forecasts.
\item A numeric scalar \code{alpha}, the optimal paramater for the exponential
smoothing component chosen during model training
\item A numeric scalar \code{alpha_seasonal}, the optimal paramater for the
seasonal exponential smoothing component chosen during model training
\item A numeric scalar \code{alpha_seasonal_decay}, the optimal paramater for the
seasonal exponential decay smoothing component chosen during model training
\item A numeric vector \code{fitted} containing fitted values for each index of \code{y};
the up to \code{period_length}-first observations may be missing.
\item A numeric vector \code{residuals} containing the residuals for the training data
as computed by \code{y - fitted}, thus the up to \code{period_length}-first
observations may be missing.
\item A numeric vector \code{y}, the input \code{y}
\item A scalar \code{n}, the number of observations provided via \code{y}
\item A scalar \code{period_length}, the input \code{period_length}
\item A function \code{loss_function}, the provided \code{loss_function}
\item A scalar \code{loss}, the value computed by the provided \code{loss_function} based
on the input \code{y} and the fitted values (ignoring the initial missing
values) for the loss minimizing set of parameters reported in \code{alpha},
\code{alpha_seasonal}, \code{alpha_seasonal_decay}
\item A logical \code{penalize}, identical to the provided function argument
\item A scalar \code{loss_increase}, identical to the provided function argument
\item A list \code{full} containing intermediate results observed during model
optimization for all other parameter combinations provided via
\code{alphas_grid}
}
}
\description{
Returns a \code{threedx} model applied to time series \code{y} after learning the
optimal set of parameters by minimizing a provided loss function. Use
\code{\link[=predict.threedx]{predict.threedx()}} to generate a forecast based on the fitted model.
}
\examples{
set.seed(9284)
y <- stats::rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi((5 + 1:55 )/ 6)))

alphas_grid <- list_sampled_alphas(
  n_target = 1000L,
  include_edge_cases = TRUE
)

model <- learn_weights(
  y = y,
  alphas_grid = alphas_grid,
  period_length = 12L,
  loss_function = loss_mae
)

if (require("ggplot2")) {
  autoplot(model)
}

model_penalized <- learn_weights(
  y = y,
  alphas_grid = alphas_grid,
  period_length = 12L,
  loss_function = loss_mae,
  penalize = TRUE,
  loss_increase = 10
)

model$full$best_alphas
model_penalized$full$best_alphas

if (require("ggplot2")) {
  autoplot(model_penalized)
}

}
\seealso{
\code{\link[=predict.threedx]{predict.threedx()}}, \code{\link[=list_sampled_alphas]{list_sampled_alphas()}}, \code{\link[=loss_mae]{loss_mae()}}
}
