% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/to_moment_matched_nbinom.R
\name{to_moment_matched_nbinom}
\alias{to_moment_matched_nbinom}
\title{Postprocess to samples from a moment-matched negative-binomial distribution}
\usage{
to_moment_matched_nbinom(x)
}
\arguments{
\item{x}{Numeric vector of non-negative samples of at least length 2}
}
\value{
Numeric vector of length equal to \code{x}
}
\description{
Use this function to postprocess samples from the forecast distribution to
samples from a negative binomial distribution that was fitted by
moment-matching (using mean and variance) to the input samples \code{x}. This is
useful to convert samples generated via a different \code{innovation_function}
like \verb{[draw_normal_with_zero_mean()]} or \verb{[draw_bootstrap()]} to a
count distribution.
}
\details{
If the required forecast output are count data (as when forecasting the
demand for products), this can be better than using \code{round()} or similar to
preserve features of the forecast distribution.
}
\examples{
x <- to_non_negative_with_identical_mean(
  stats::rnorm(n = 10000, mean = 5, sd = 3)
)
y <- to_moment_matched_nbinom(x = x)
summary(x); stats::var(x)
summary(y); stats::var(y)

# Forecasting simple count data

set.seed(992)
y <- stats::rnbinom(n = 50, mu = 3, size = 3/2)
model <- learn_weights(
  y = y,
  alphas_grid = list_sampled_alphas(
    n_target = 1000L,
    include_edge_cases = TRUE
  ),
  period_length = 12L,
  loss_function = loss_rmse
)

forecast <- predict(
  object = model,
  horizon = 12L,
  n_samples = 2501L,
  observation_driven = FALSE,
  innovation_function = draw_normal_with_zero_mean,
  postprocess = to_moment_matched_nbinom
)

forecast$paths[1:5, ]

if (require("ggplot2")) {
  autoplot(forecast)
  autoplot(forecast, method = "paths")
}

}
\seealso{
\code{\link[=predict.threedx]{predict.threedx()}}, \code{\link[=to_non_negative_with_identical_mean]{to_non_negative_with_identical_mean()}}
}
