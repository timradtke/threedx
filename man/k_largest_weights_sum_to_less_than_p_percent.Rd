% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/k_largest_weights_sum_to_less_than_p_percent.R
\name{k_largest_weights_sum_to_less_than_p_percent}
\alias{k_largest_weights_sum_to_less_than_p_percent}
\title{Do the \code{k} largest weights sum up to less than \code{p}\% of the total weights?}
\usage{
k_largest_weights_sum_to_less_than_p_percent(weights, k, p)
}
\arguments{
\item{weights}{A vector of weights that sum to 1, as part of the model
object returned by \code{\link[=learn_weights]{learn_weights()}}}

\item{k}{The number of weights to consider, in decreasing order of their size}

\item{p}{The threshold of cumulative probability under which the \code{k} weights
might be}
}
\value{
A logical of length 1
}
\description{
Use this function to dynamically set \code{observation_driven} based
on the fitted model's weights.
}
\details{
This is useful to judge whether a trained \code{threedx} model's prediction is
the combination of at least a few historical observations. When using
\code{observation_driven} during prediction, prediction intervals collapse to a
single point when a single historical observation has (close to) 100\% of the
weights (which happens, for example, for the random walk or seasonal naive
models). In those cases it can be better to switch to
\code{observation_driven = FALSE} to get a non-collapsed prediction interval
based on sampling residuals.

\code{k_largest_weights_sum_to_less_than_p_percent()} can be used to make this
switch dynamically, based on the fitted weights. See also the examples below.
}
\examples{
k_largest_weights_sum_to_less_than_p_percent(
  weights = c(0.02, 0.05, 0.05, 0.04, 0.8, 0.03, 0.01),
  k = 3,
  p = 0.9
)

k_largest_weights_sum_to_less_than_p_percent(
  weights = c(0.02, 0.05, 0.05, 0.04, 0.8, 0.03, 0.01),
  k = 4,
  p = 0.9
)

# Now apply it dynamically during prediction to set `observation_driven`

set.seed(9284)
y <- stats::rpois(n = 55, lambda = pmax(0.1, 1 + 10 * sinpi((5 + 1:55 )/ 6)))

model <- learn_weights(
  y = y,
  alphas_grid = list_sampled_alphas(
    n_target = 1000L,
    include_edge_cases = TRUE
  ),
  period_length = 12L,
  loss_function = loss_mae
)

forecast <- predict(
  object = model,
  horizon = 12L,
  n_samples = 2500L,
  innovation_function = draw_normal_with_zero_mean,
  observation_driven = k_largest_weights_sum_to_less_than_p_percent(
    weights = model$weights,
    k = 4,
    p = 0.95
  )
)

print(forecast$observation_driven)

}
\seealso{
\code{\link[=predict.threedx]{predict.threedx()}}, \code{\link[=learn_weights]{learn_weights()}}
}
